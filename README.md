### **Бінарне дерево**
Бінарне дерево — це структура даних, у якій кожен вузол має не більше двох дочірніх вузлів: **лівий** (менші значення) та **правий** (більші значення). У бінарному дереві пошуку елементи впорядковані так, що дублювання значень не допускається.

#### **Додавання елементів**
1. **Корінь дерева (root)** — це початковий вузол. Наприклад, якщо `5` є коренем:
   - Додавання `10`: оскільки `10 > 5`, елемент додається праворуч.
   - Додавання `1`: оскільки `1 < 5`, елемент додається ліворуч.
2. Вузли далі формують свою структуру:
   - Якщо `3 < 5`, але `3 > 1`, то `3` розташовується праворуч від `1`.

---

### **Переваги**
- **Швидкий пошук:** Бінарне дерево реалізує ефективний бінарний пошук.
- **Ієрархічна структура:** Легке управління елементами завдяки впорядкованому розташуванню.

---

### **Операції**
1. **Видалення вузлів:**  
   Видалення можливе у трьох випадках:
   - Вузол не має дочірніх елементів.
   - Вузол має одного дочірнього вузла.
   - Вузол має два дочірні вузли (тут потрібно замінити вузол на мінімальний елемент із правого піддерева).

2. **Рекурсивне копіювання дерева (`CopyTree`)**  
   ```cpp
   void BinaryTree<T>::CopyTree(Node*& tree1, Node* const& tree2) {
       if (tree2 == nullptr) return;
       tree1 = new Node{ tree2->data }; // Створюємо вузол
       CopyTree(tree1->left, tree2->left); // Ліва гілка
       CopyTree(tree1->right, tree2->right); // Права гілка
   }
   ```

3. **Очищення дерева (`Clear`)**  
   - Видаляє всі піддерева через `RemoveSubTree()`.
   - Після цього корінь дерева встановлюється в `nullptr`.

4. **Видалення піддерева (`RemoveSubTree`)**  
   - Рекурсивно видаляє всі вузли, починаючи з найглибших.  
   - Логіка: спочатку видаляємо ліве піддерево, потім праве, а далі сам вузол.

5. **Деструктор (`~BinaryTree`)**  
   - Використовує метод `Clear()` для повного звільнення пам'яті.

6. **Оператор присвоєння (`operator=`)**  
   - Якщо дерева різні, то очищує поточне дерево і копіює нове через `CopyTree()`.

---

### **Допоміжні методи**
1. **`IsEmpty()`**  
   Перевіряє, чи є дерево порожнім (`root == nullptr`).

2. **`Size()`**  
   Повертає кількість елементів у дереві:
   ```cpp
   Size(node->left) + 1 + Size(node->right)
   ```

3. **`Insert(const T& value)`**  
   Додає новий елемент, якщо його ще немає в дереві.  
   Перевіряє:
   - Якщо `value` менше — додає ліворуч.
   - Якщо більше — праворуч.

4. **`DoForAllElements(Func function)`**  
   Викликає задану функцію для всіх елементів дерева за допомогою рекурсії.

5. **`Find`**  
   Реалізує бінарний пошук для знаходження вузла.

6. **`FindMinimum(Node* node)`**  
   Знаходить мінімальний елемент у дереві (ліворуч до кінця).

---

### **Основні принципи роботи**
- **Пошук мінімального/максимального елемента:** Перехід через ліві/праві вузли до кінця.  
- **Рекурсивність:** Більшість операцій виконуються через рекурсивні виклики методів.
- **Робота з пам'яттю:** Структура звільняє пам'ять після видалення вузлів, уникаючи витоків.

