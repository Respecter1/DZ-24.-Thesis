
Бінарне дерево - не може містити дублювання типу дві 5 і тд 


				в самому інарному дереві є вузли 
				в бінарному дереві є вказівник на лівий вузов та на правий вузов
				якщо в нашому бінарному дереву 5 по середені і ми хочемо добавити 10 
				то наша 10 буде добовлятись с права бо 10 > 5 потім у 10 теж формирується 
				2 направления вправо(більше) та вліво(менше). Корінь(root) це наша 5 ми хочемо 
				добавити 1 і так як 1 < 5 вона пійде в ліво. далі ми хочемо добавити допустимо 3
				3 < 5 потім воно починає зрівнювати 1 з нашою 3  3 > 1 і воно йде в право і створюється новий корінь 
				в бінарному дереві пошуку не може бути дублювання елементів не може юути 2 п'ятіркі і тд...

які в у неї переваги порівняно с другими абстрактними структурами це швидкість в пошуку (бінарний пошук).

видалеення є 3 варіанти:
						 1) у вузлі вказівники нікуди не указують
						 2) коли є один із дочірніх вузлів
						 3) коли є 2 дочірні вузла


template<typename T>
void BinaryTree<T>::CopyTree(Node*& tree1, Node* const& tree2)
{
	if (tree2 == nullptr)
	{
		return;
	}

	tree1 = new Node{ tree2->data }; - створюю на кучі просто вузов на якому буде значення 5 і він нічому не буде дорівнювати
	CopyTree(tree1->left, tree2->left);рекурсивно викликаю той самий метод 
	CopyTree(tree1->right, tree2->right);//правий вузов

}

Clear() - якщо в нас є хоч 1 елемент то викликає RemoveSubTree то я через тей метод хочу видалить під дерево
		 цього вузла, а потім я зануляю наш корінь 
		 можна ще вот так сказати, я видаляю всі піддерева коли я видалив їх то потім можу видалити корінь


RemoveSubTree() - якщо від мого корня з ліва є щось то if (node->left != nullptr), то я корінь не удаляю 
				  я викликаю цей же метод рекурсивно RemoveSubTree() і заново ййду по вузлу, і розуміємо що 
				  наше вузол ми не можемо видалити корінь поки у його є піддерева 
				  тоб-то коротко кажучи ми повинні йти снизу до верху, видалити самий низ і підніматись до верху 
				  в цьому методі ми спочатку йдемо по лівій стороні потім по правій як в методі копії тільки видаляємо 

~Деструктор() - теж має метод клір

operator= (const BinaryTree& other) - (оператор присвоєння копією) там стоїть перевірка якщо адреса різна,
								      то я методом Clear() видаляю все і вставляю CopyTree()(тоб-то копіюю рекурсивно)
									  свої дерева.

IsEmpty() - метод який перевіряє чи корінь пустий чи ні, якщо так то тру ні фолсе

Size() - розмір, він викликає свою перезавантажену версію Size(const Node* node) яка запускає перевірку 
		 якщо наш вузов не існує то за нього 0, а в іншому випадку я кажу перевірити 
		 : Size(node->left) + 1 + Size(node->right) я повертаю +1 та запускаю ще 1 перевірку 
		 вузлів з правої та лівої сторони якщо з якоюсь сторони все таки є вузов то опять рекурсія

Insert(const T& value) - він повертає правду якщо елемент втавився це дозволяє мені перевірити щоб не було 
						 ніяких дублікатів
						if (root == nullptr) якщо була пустота то я виділяю пам'ять 
						далі ми  Node* node = root; створюємо корінь
						в циклі  while (node != nullptr) поки ми не дойдем до 0 поинтера
						if (node->data == value) якщо у нас наші данні нашого вузла збігаються 
						з нашим значенням значить у нас дублювання 
						else if (node->data > value) якщо наше значення менше за данні 
						node->data - це наше число корінь а це число яке ми хочемо вставити value
						(node->left == nullptr) якщо з ліва пусто 
						якщо наше число більше за корінь то спрацює else і в ньому теж перевірка 
						чи наше місце свободно для нашого числа якщо nullptr то встановлюєємо там наше 
						число якщо ні то переходимо в цей вузов і заново спрацьовую порівняння 
						бо цикл така механіка

DoForAllElements(Func function) - сюди відправляється якась функція, цей код рекурсивно викликає метод DoForNode(const Node* node, Func function)
		
DoForNode(const Node* node, Func function) - якщо не дорівнює нулю значеня 
											то воно по класиці викликає для лівого потім якщо іф там не спрацьовує 
											то спочатку викликаємо наше число потім йдемо по правому і повторяємо туж махінацію 


Find - бінарний пошук

FindMinimum(Node* node) - находимо мінімальне значення 